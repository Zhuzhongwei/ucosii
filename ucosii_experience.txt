https://blog.csdn.net/tangxing1212/article/details/49931867#comments
1.UCOSII的任务如何分类？

  1）用户创建的任务：用户最多可以创建63个任务，优先级0~62,0是最高优先级任务。

  2）系统创建的任务：空闲任务和统计任务（计算在运行所有应用程序时，CPU的使用效率）。在使用UCOSII前，必须调用OSInit(),OSInit()可以建立了空闲任务和统计任务。

  注：所有任务的优先级必须不相同。

2.UCOSII创建任务的要素？

  1）编写自己的任务函数。

  2）分配一个适合的任务堆栈。

  3）分配一个合适的任务优先级。

  4）可能还需要给任务传递一些参数。

3.任务函数的特点？

  1）没有返回值。

  2）都包含了一个死循环。

  3）都有一个void型的指针形参。

  4）死循环内必须有调度点。

  5）高优先级的任务中必须有等待延迟，让低优先级的任务有被调度的机会。

4.用OSStart()开启了UCOSII后，每个任务建立的时候，UCOSII会判断新建立的任务是否具有最高优先级，如果其优先级最高，则立即运行该任务。

5.如何检测一个任务堆栈的大小？

  考虑使用OSTaskStkChk()堆栈检查函数。此函数的运行时间与任务所指定的堆栈大小密切相关。当想确认一个任务需要多少堆栈时，此函数是很有用的。如果系统对稳定性要求高，实际分配的堆栈应大于检查的最大值得1倍。堆栈检查要求任务建立时给堆栈清零，也要注意，其实进行堆栈清零也可能是一项很费时的工作。执行OSTaskStkChk()堆栈检查函数，也就是从栈低向栈顶搜索非0的元素，记录0元素的个数。

6.何为消息邮箱？

  消息邮箱仅能提供一个指针型变量的传递，至于此指针型变量到底指向什么样的数据结构，是由使用此邮箱的用户程序共同决定的。

7.如何确定每个任务的运行次数和运行时间？

  系统的钩子函数可以解决此问题。钩子函数其实在应用中必不可少。
  
1.在UCOS中创建任务时，要注意堆栈的增长方式不要搞错。

2.0x12345678的存储大端格式：

低地址<--0x12|0x34|0x56|0x78-->高地址

3.0x12345678的存储小端格式：

低地址<--0x78|0x56|0x34|0x12-->高地址

4.MIPS/MHZ就是说每1MHZ频率能产生多大的MIPS。以前计算机大部分都是单线程，就是说1秒钟如果振荡周期是1MHZ的话，取指，译码，操作只能串行进行，计算机1秒钟处理的指令也不会超过1M条。而现在计算机都在使用多级流水线结构，取指，译码，操作可以认为能够并行，也就是说1秒钟处理的指令也可以超过1M条。

5.MIPS是计算机每秒执行百万条指令的简写。现在CPU的频率越来越高，又是多级流水线，又是超标量，又是多核，单纯用时钟频率来衡量计算机的速度，已经不再科学，用MIPS来衡量相对合理。

6.MIPS架构也是一种采取精简指令集的处理器架构，1981年，由MIPS科技公司开发并授权，现在ARM买了MIPS的使用权。

7.UCOSII全部的函数调用与服务的执行时间都是具有可确定性，不依赖于任务的多少。

8.并发工作并不是真真的同时工作，并发只是各任务轮流占用CPU，而不是同时占用，任何时候其实只用一个任务在占用CPU资源。

9.任务的5种状态：

1:休眠态：驻留在内存，没有交给内核管理，其实也就是没有为此任务分配任务控制块。可以通过调用任务创建函数把任务交给内核。

2:就绪态：可以运行，但优先级没有在运行的任务高。

3:运行态：正在占用CPU使用权。

4:挂起（等待）态：等待信号量，等待延迟时间结束等等。

5:被中断态。

10.对于全局变量，实时数据处理,共享数据等要注意临界区代码的保护。

https://blog.csdn.net/tangxing1212/article/details/51396361

1.OS_TCB任务控制块全部驻留在RAM中，这是值得注意的，特别是在RAM缺乏的时候。

2.任务的管理：

 1：建立和删除任务。（注意：任务删除要考虑任务资源的释放。）

 2：请求删除任务：如果任务A运行一段时间已经拥有了一些资源，而任务B想删除它，要是强制删除，这些资源可能没有释放。

 3：改变任务优先级。

 4：挂起和恢复任务。

3.信号量由两部分组成：信号量的计数值和等待该信号量任务的等待列表。主要用于资源共享和任务同步。

4.Malloc和free对内存操作的缺点：1：多次操作会产生内存碎片。2：执行时间并不确定。

5.可重入的代码可以被一个以上的任务调用，而不必担心数据的破坏。

6.void OSCtxSw(void);//用户任务切换

   void OSIntCtxSw(void);//中断任务切换

   void OSStartHighRdy(void);//操作系统第一次启动的时候调用的任务切换。

   void OSPendSV(void);//用户中断处理函数

7.任务函数的局部变量越多，嵌套层数越多，堆栈越偏大，也要注意堆栈对齐问题。

8.Volatile作用是阻止编译器进行优化，每次读取或修改值的时候，都必须重新从内存中或外设寄存器中读取或修改，防止从缓冲处读取的值是过期的。

9.Volatile应用场合：

 1：中断ISR中修改，供其它程序检测的变量。

 2：多任务下任务共享的变量资源。

 3：外设的寄存器地址。

10.STM32中UCOSII的系统时钟节拍

void SysTick_Handler(void)

{

  if(delay_osrunning==1)//OS开始跑了,才执行正常的调度处理

  {  OSIntEnter(); //进入中断

     OSTimeTick(); //判断延迟的任务是否到达时间等 ????????????

     OSIntExit(); //触发任务切换软中断

  }

}

一．OSQPost以FIFO(先进先出的方式)组织消息队列。OSQPostFront以LIFO(后进先出的方式)组织消息队列。

二．信号量定义，创建，使用简例。

 1.信号量的定义

 OS_EVENT *SEM1;

 2.信号量的创建

 SEM1=OSSemCreate(0);

 3.等待一个信号量

 INT8U err;

 OSSemPend(SEM1,0,&err);

 4.发送一个信号量

 OSSemPost(SEM1);

三．邮箱定义，创建，使用简例。

 1.邮箱的定义

 OS_EVENT *Mbox1;

 2.邮箱的创建

 Mbox1=OSMboxCreate((void *)0);

 3.等待一个邮箱

 INT8U err;

 Unsigned char *msg;

 msg=(unsigned char*)OSMboxPend(Mbox1,0,&err);

 4.发送一个邮箱

 unsigned char msg[10];

 OSMboxPost(Mbox1,(void *)&msg);

四．消息队列定义，创建，使用简例。

1.消息队列的定义

OS_EVENT *msgqueue;

Void *MsgQueue[9];

2.消息队列的创建

msgqueue=OSQCreate(&MsgQueue[0],9);

3.等待一个消息队列

INT8U err;

Unsigned char *msg;

msg=(unsigned ??char*)OSQPend(msgqueue,0,&err);

4.发送一个消息队列

unsigned char msg1=’1’;

unsigned char msg2=’2’;

?......

unsigned char *msg9=’9’;



OSQPost(msgqueue,(void *)&msg1);

OSQPost(msgqueue,(void *)&msg2);
