调度器介绍:

简单的说，调度器就是使用相关的调度算法来决定当前需要执行的任务。所有的调度器有一个共同的
特性：调度器可以区分就绪态任务和挂起任务（由于延迟，信号量等待，邮箱等待，事件组等待等原因而
使得任务被挂起）。调度器可以选择就绪态中的一个任务，然后激活它（通过执行这个任务）。当前正在
执行的任务是运行态的任务。不同调度器之间最大的区别就是如何分配就绪态任务间的完成时间。
嵌入式实时操作系统的核心就是调度器和任务切换，调度器的核心就是调度算法。任务切换的实现在
各个 RTOS 中区别不大，基本相同的架构，任务切换也是相似的。调度算法就有些区别了，比如咱要讲的
μCOS-III 和 FreeRTOS 在抢占式调度器算法上就是两种不同的调度方法，下面我们主要了解一下合作式
调度器，抢占式调度器和时间片调度器

合作式调度器
 合作式调度器提供了一种单任务的的系统结构
操作：
 在特定的时刻被调度运行（以周期性或者单次方式）
 当任务需要运行的时候，被添加到等待队列。
 当 CPU 空闲的时候，运行等待队列中的下一个（如果有的话）。
 任务运行直到完成，然后由调度器来控制。
实现：
 这种调度器很简单，用少量代码即可实现。
 该调度器必须一次只为一个任务分配存储器。
 该调度器通常完全由高级语言（比如“C”）实现。
 该调度器不是一种独立的系统，它是开发人员代码的一部分。
新能：
 设计阶段需要小心以快速响应外部事件。
可靠性和安全性：
 合作式调度简单，可预测，可靠并且安全。

合作式调度器提供了一种简单而且可预测性非常高的平台。该调度器全部用 C 语言实现而且成为系统
的的一部分。这将使整个系统的运行更加清晰，而且易于开发，维护以及向不同平台上面移植。存储器的
开销为每个任务 16 个字节，对 CPU 的要求（随时标间隔而变，也就是嘀嗒定时器的周期）很低。
合作式调度器主要由以下几部分组成：
 调度器数据结构
typedef unsigned char tByte;
typedef unsigned int tWord;
typedef struct
{
	void (*pTask)(); /*指向任务的指针必须是一个*void(void)*函数； */
	tWord Delay; /*延时（时标）知道下一个函数的运行*/
	tWord Period; /*连续运行之间的间隔*/
	tByte RunMe; /*当任务需要运行的时候由调度器加 1*/
}sTask;
这个结构体需要占用 16 个字节，为什么是 16 个字节而不是 13 个字节，指针函数占用 4 个字节 +
Delay 占用 4 个字节 + Period 占用 4 个字节 + RunMe 占用 1 个字节 = 13 个字节。实际测试中发现做
了结构体会以组员中占用字节最多的类型做字节对齐，比如上面这个就是按照 16 个字节来算。
typedef struct
{
	unsigned short int RunMe1;
	unsigned char RunMe2;
	unsigned char RunMe3;
	unsigned char RunMe4;
}sTask1;

任务队列的大小通过下面进行定义：
#define SCH_MAX_TASKS 5
sTask SCH_task_G[SCH_MAX_TASKS]; /*建立的任务数*/
建立任务的时候要注意不能超过这个最大任务数。
 初始化函数
这里的初始化函数主要是指滴答定时器的初始化，以此来产生调度器所需要的时标。一般情况下把时
标间隔都设置为 1ms。关于嘀嗒定时器方面的知识已经在前面第 10 章： SysTick 实验有详细的讲解，这
里就不再赘述了，只把初始化函数贴出来：
/*
*******************************************************************************************
* 函 数 名: bsp_InitTimer
* 功能说明: 配置 systick 中断，并初始化软件定时器变量
* 形 参: 无
* 返 回 值: 无
*******************************************************************************************
*/
void bsp_InitTimer(void)
{
	uint8_t i;
	/* 清零所有的软件定时器 */
	for (i = 0; i < TMR_COUNT; i++)
	{
	s_tTmr[i].Count = 0;
	s_tTmr[i].PreLoad = 0;
	s_tTmr[i].Flag = 0;
	s_tTmr[i].Mode = TMR_ONCE_MODE; /* 缺省是 1 次性工作模式 */
}
	/*
	配置 systic 中断周期为 1ms，并启动 systick 中断。
	SystemCoreClock 是固件中定义的系统内核时钟，对于 STM32F4XX,一般为 168MHz
	SysTick_Config() 函数的形参表示内核时钟多少个周期后触发一次 Systick 定时中断.
	-- SystemCoreClock / 1000 表示定时频率为 1000Hz， 也就是定时周期为 1ms
	-- SystemCoreClock / 500 表示定时频率为 500Hz， 也就是定时周期为 2ms
	-- SystemCoreClock / 2000 表示定时频率为 2000Hz， 也就是定时周期为 500us
	对于常规的应用，我们一般取定时周期 1ms。对于低速 CPU 或者低功耗应用，可以设置定时周期为 10ms
	*/
	SysTick_Config(SystemCoreClock / 1000);
}
这里有一点要特别的强调下:
意思就是说：如果用户使用时间触发模式，强烈建议只用一个中断，这个中断用于调度器的时标，如
果用户还使用了其它中断，那么基于时间触发模式的可预测性和可靠的系统结构将被破坏。
 
	嘀嗒定时器中断，用来以一定的时间间隔刷新调度器
	刷新函数的主要功能是：每个时标中断执行一次。在嘀嗒定时器中断里面执行。当刷新函数确定某个
任务要执行的时候，将这个任务结构体的成员 RunMe 加 1，要注意的是刷新任务不执行任何函数，这里
只是设置 一下 RunMe 标志，由调度函数根据此标志执行相应任务。
下面是具体的函数代码
/*
*******************************************************************************************
* 函 数 名: SCH_Update(void)
* 功能说明: 调度器的刷新函数，每个时标中断执行一次。在嘀嗒定时器中断里面执行。
* 当刷新函数确定某个任务要执行的时候，将 RunMe 加 1，要注意的是刷新任务
* 不执行任何函数，需要运行的任务有调度函数激活。
* 形 参：无
* 返 回 值: 无
*******************************************************************************************
*/
void SCH_Update(void)
{
	tByte index;
	/*注意计数单位是时标，不是毫秒*/
	for(index = 0; index < SCH_MAX_TASKS; index++)
	{
		/*检测这里是否有任务*/
		if(SCH_task_G[index].pTask)
		{
			if(SCH_task_G[index].Delay == 0)
			{
			/*任务需要运行 将 RunMe 置 1*/
			SCH_task_G[index].RunMe += 1;
			if(SCH_task_G[index].Period)
			{
				/*调度周期性的任务再次执行*/
				SCH_task_G[index].Delay = SCH_task_G[index].Period;
			}
		}
		else
		{
			/*还有准备好运行*/
			SCH_task_G[index].Delay -= 1;
			}
		}
	}
}
 向调度器增加任务函数
添加任务函数的主要功能是将任务添加到任务队列上，下面主要是说一下这个函数中参数的功能：
tByte SCH_Add_Task(void (*pFuntion)(void), tWord DELAY, tWord PERIOD)
1. void (*pFuntion)(void) ：表示函数的地址，也就是将函数名填进去就行了。
2. DELAY ：表示函数第一次运行需要等待的时间。
3. PERIOD：表示函数周期性执行的时间间隔
举四个例子说明一下：
 SCH_Add_Task(DOTASK, 1000, 0)
DOTASK 是函数的运行地址，1000 是 1000 个时标以后开始运行，只运行一次。
 SCH_Add_Task(DOTASK, 0, 1000)
DOTASK 是函数的运行地址，每个 1000 个时标周期性的运行一次。
 SCH_Add_Task(DOTASK, 300, 1000)
DOTASK 是函数的运行地址，300 是 300 个时标以后开始运行，以后就是每 1000 个时标周期运行一
次，也就是说运行时刻是 300，1300，2300，3300，4300 等等。
 Task_ID = SCH_Add_Task(DOTASK,1000,0);
Task_ID 是任务标示符，将任务标示符保存 以便以后删除任务。
下面是函数的源代码：
/*
*******************************************************************************************
* 函 数 名: SCH_Add_Task
* 功能说明: 添加任务。
* 形 参： void (*pFuntion)(void) tWord DELAY tWord PERIOD
* 返 回 值: 返回任务的 ID 号
*******************************************************************************************
*/
tByte SCH_Add_Task(void (*pFuntion)(void),
					tWord DELAY,
					tWord PERIOD)
{
	tByte index = 0; /*首先在队列中找到一个空隙，（如果有的话） */
	while((SCH_task_G[index].pTask != 0) && (index <SCH_MAX_TASKS))
	{
		index ++;
	}
	if(index == SCH_MAX_TASKS)/*超过最大的任务数目 则返错误信息*/
	 使任务在应当运行的时候被执行的调度函数
	 从调度器删除任务的函数（此功能未做）
	{
		Error_code_G = ERROR_SCH_TOO_MANY_TASKS;/*设置全局错误变量*/
		return SCH_MAX_TASKS;
	}
	SCH_task_G[index].pTask = pFuntion; /*运行到这里说明申请的任务块成功*/
	SCH_task_G[index].Delay = DELAY;
	SCH_task_G[index].Period = PERIOD;
	SCH_task_G[index].RunMe =0;
	return index; /*返回任务的位置，以便于以后删除*/
}
在前面已经说过，刷新函数不执行任何函数任务，需要运行的任务由调度函数激活。下面是调度函数
的源码：
/*
*******************************************************************************************
* 函 数 名: SCH_Dispatch_Tasks
* 功能说明: 在主任务里面执行的调度函数。
* 形 参：无
* 返 回 值: 无
*******************************************************************************************
*/
void SCH_Dispatch_Tasks(void)
{
	tByte index;
	/*运行下一个任务，如果下一个任务准备就绪的话*/
	for(index = 0; index < SCH_MAX_TASKS; index++)
	{
		if(SCH_task_G[index].RunMe >0)
		{
			/*执行任务 */
			(*SCH_task_G[index].pTask)();
			/* 执行任务完成后，将 RunMe 减一 */
			SCH_task_G[index].RunMe -= 1;
			/*如果是单次任务的话，则将任务删除 */
			
			if(SCH_task_G[index].Period == 0)
			{
				SCH_Task_Delete(index);
			}
		}
	}
}


2.3 合作式调度器注意事项
 只有一个中断的原则
这个原则应该在很大程度上限制了基于时间触发的合作式调度器使用范围，比如我们想使用按键中断
来及时的响应外部事件。如果不使用中断，那么外部事件将无法得到及时的响应


任务重叠的问题
任务重叠是怎么回事呢？举个例子：假如有两个任务 A 和 B，A 任务每隔 1s 运行一次，B 每隔 3s 运
行一次，两个任务的运行时间都是 0.5ms，运行时标是 1ms
SCH_Add_Task(TASKA, 0, 1000);
SCH_Add_Task(TASKB, 0, 3000);
这个例子中会出现两个任务同时运行的情况，而且 A 任务在 B 任务之前运行，这就意味着如果 A 任务运
行时间有变化，那么 B 任务将出现“抖动”，当两个任务重叠的时候，则不能在正确的时间调用。
或者，假设以如下的方式调度这些任务
SCH_Add_Task(TASKA, 0, 1000);
SCH_Add_Task(TASKB, 5, 3000);
这样在很大程度上就避免了任务的重叠，因为 B 任务总是在 A 任务后 5ms 才会运行，还有一个解决任务
重叠的办法，不过这个办法不适合在软件上面实现（适合用硬件来实现，比如 FPGA，这就是为什么 Michael
J. Pont在TTE32微控制器中集成硬件时间触发的合作式调度器），这里简单的介绍下这个方面的实现思路：
首先我们需要得到任务最坏情况的执行时间（这个不容易得到，我们只能得到一个大概的时间，因为很多
情况是我们无法现场模拟的），然后设置一个任务最大执行时间，一旦任务超多了这个时间，那么就将任
务关闭，然后根据需要执行备份任务，这个备份任务也是偶最大执行时间要求的，要不会影响其它任务的
执行。这种解决办法比较难，大家作为了解就行。

任务超时的问题
使用合作式调度器的应用程序有一个重要的要求：任务的运行时间 < 时标间隔 这个要求非常重要，
而且实现起来额不容易，特别是程序中含有一些无法确定时间的函数，比如下面这个：
do
{
	HSEStatus = RCC->CR & RCC_CR_HSERDY;
} while(HSEStatus == 0);

这个时候我们就需要用下面这种形式的函数来实现
do
{
	HSEStatus = RCC->CR & RCC_CR_HSERDY;
	StartUpCounter++;
} while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));























抢占式调度器
如果使用了抢占式调度，最高优先级的任务一旦就绪，总能得到 CPU 的控制权。当一个运行着的任
务使一个比它优先级高的任务进入了就绪态，当前任务的 CPU 使用权就被剥夺了，或者说被挂起了，那
个高优先级的任务立刻得到了 CPU 的控制权。如果是中断服务子程序使一个高优先级的任务进入就绪态，
中断完成时，中断了的任务被挂起，优先级高的那个任务开始运行。

使用抢占式调度器，使得最高优先级的任务什么时候可以执行，可以得到 CPU 的控制权是可知的，
同时使得任务级响应时间得以最优化。

总的来说，学习抢占式调度掌握最关键的一点是：抢占式调度器会为每个任务都分配一个优先级，调
度器会激活就绪任务中优先级最高的任务。

抢占式调度器给任务带来快速响应的同时也使得任务间的同步和
通信机制显的很麻烦，而且源码中的很多地方都需要设置临界段（通过开关中断来实现）。


时间片调度器
在小型的嵌入式 RTOS 中，最常用的的时间片调度算法就是 Round-robin 调度算法。这种调度算法
可以用于抢占式或者合作式的多任务中，时间片调度适合用于不要求任务实时响应的情况下。
实现 Round-robin 调度算法需要给同优先级的任务分配一个专门的列表，用于记录当前就绪的任务，
并为每个任务分配一个时间片（也就是需要运行的时间长度，时间片用完了就进行任务切换）。
目前 embOS，FreeRTOS，μCOS-III 和 RTX 都支持 Round-robin 调度算法