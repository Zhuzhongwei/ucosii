抢占式调度器介绍

抢占式调度器
 抢占式调度器提供了一种多任务的系统结构
操作：
 任务在特定的时刻被调度运行（以周期性或者单次方式）
 当任务需要运行的时候，被添加到等待队列。
 等待的任务（如果有的话）运行一段固定的时间，如果没有完成，将被放回到等待队列。然后
下一个等待任务将会运行一段固定的时间，以此类推。
实现：
 这种调度器相对复杂，访问共享资源时，要防止冲突。
 该调度器必须为强占任务的所有中间状态分配存储器。
 该调度器通常将（至少部分）由汇编语言编写。
 该调度器通常作为一个独立的系统被创建。
性能：
 对外部事件的响应速度快
可靠性和安全性：
 与合作式任务相比，通常认为更不可预测，并且可靠性低。

使用抢占式调度器最大的好处是对外部事件的快速响应，提高系统的实时性。带来好处的同时也是要付出
代价的，下面就举一个例子，这个例子比较典型。
假设系统中的一个任务要从 ADC 端口读取模拟信号，这时发生了上下文切换，另一个任务也要访问
这个端口，在这种情况下如果不采取措施阻止这种情况，数据将可能丢失或者破坏。这种问题往往出现在
多任务平台中所谓的“临界段”，这些代码段一旦开始就必须不中断地运行，直到跑完这段代码。临界段
还有很多，比如：
 读取或者修改变量（特别是任务间通信的全局变量）的代码，一般来说这时最常见的关键代码。
 如果读过μCOS-II 或μCOS-III 源代码的话，会发现里面很多地方都做了开关中断的处理，就是为了
防止多任务造成错误。
 调用公共函数的代码，特别是不可重入的函数，如果多个任务都访问这个函数，结果是可想而知的。
解决这种情况最常用的的办法就是在临界段做开关中断处理，这种情况是最影响实时性的，如果关中断期
间发生了外部中断事件，那么这个中断事件只有临界段执行完之后才能得到相应。还有一种解决办法就是
使用调度锁，这样在一定程度上能够提供任务的实时性，在发生外部中断的时候会得到相应，但是不会发
生任务切换，必须等到调度锁被解开

混合式调度器介绍
合作式调度器为各种嵌入式系统提供了一个可预测的平台。在一些场合可能需要在合作式调度器结构
中加入抢占式调度器的一些特性，并小心的加以控制，混合式调度器应运而生。
混合式调度器综合了合作式调度器和抢占式调度器的特性，而且这种方式始终是受控的，不依赖复杂
的上下文切换程序，以及任务间复杂的通信机制。下面是混合式调度器的特性：
混合式调度器
 混合式调度器提供了有限的多任务处理能力。
操作：
 支持多个合作式调度的任务。
 支持一个抢占式任务（可以中断合作式任务）。
实现：
 这种调度器很简单，用少量代码即可实现。
 该调度器必须同时为两个任务分配存储器。
 该调度器通常完全由高级语言（比如” C” 实现）。
 该调度器不是一种独立的系统，它成为开发人员的代码的一部分。
性能：
 对外部事件的响应速度快
可靠性和安全性：
 只要小心设计可以和纯碎的合作式调度器一样可靠。

这里所描述的混合式调度器和合作式调度器是有区别的，区别如下：
 不再要求所有任务都在时标间隔之间完成任务。一个（或者更多）的合作式任务的运行时间可以大
于时标间隔。
 与前面讨论的合作式调度器一样，可以调度任意个合作式任务。然而，还可以同时调度一个抢占式
任务。武汉安富莱电子有限公司

 抢占式任务可以抢先（中断）合作式任务。
 一旦抢占式任务开始运行，将一直运行到完成。
同时注意：
 与完全的抢占式解决方案相比，只有一个抢占式任务，而且该任务连续运行直到完成，这将及大地
简化系统的结构。尤其是不需要实现上下文切换的机制。这意味着：1. 该结构仍然十分简单。 2. 运
行环境可以全部由 C 实现。
 和完全的抢占式调度器相比，简化了任务间的通信。
 应该只有一个短任务（最长的运行时间大于为时标间隔的%50，尽可能的短）可以强占运行，否则
将削弱系统的整体性能。

混合式调度器设计
上期教程我们讲解了合作式调度器设计，只要稍作修改就可以改为混合式调度器。可以看到，很多设
计人员使用混合式设计仅仅是因为它很容易实现，这通常是错误的。因为在混合式调度器中已经没有了合
作式的调度特性，这可能对设计过程和以及最终系统的可靠性带来深远的影响，在使用混合式调度器的时
候，大家要特别注意这点。
混合式调度器主要由以下几部分组成：
 1.调度器数据结构
typedef unsigned char tByte;
typedef unsigned int tWord;
typedef struct
{
	void (*pTask)(); /*指向任务的指针必须是一个*void(void)*函数； */
	tWord Delay; /*延时（时标）知道下一个函数的运行*/
	tWord Period; /*连续运行之间的间隔*/
	tByte RunMe; /*当任务需要运行的时候由调度器加 1*/
	tByte Co_op; /*混合式调度和合作式调度的区分 合作式 1 抢占式 0*/
}sTask;
任务队列的大小通过下面进行定义：
#define SCH_MAX_TASKS 5
sTask SCH_task_G[SCH_MAX_TASKS]; /*建立的任务数*/

 2.初始化函数
这里的初始化函数主要是指滴答定时器的初始化，以此来产生调度器所需要的时标。一般情况下把时
标间隔都设置为 1ms。关于嘀嗒定时器方面的知识已经在前面第 10 章： SysTick 实验有详细的讲解，这
里就不再赘述了，只把初始化函数贴出来：
/*
*******************************************************************************************
* 函 数 名: bsp_InitTimer
* 功能说明: 配置 systick 中断，并初始化软件定时器变量
* 形 参: 无
* 返 回 值: 无
*******************************************************************************************
*/
void bsp_InitTimer(void)
{
	uint8_t i;
	/* 清零所有的软件定时器 */
	for (i = 0; i < TMR_COUNT; i++)
	{
	s_tTmr[i].Count = 0;
	s_tTmr[i].PreLoad = 0;
	s_tTmr[i].Flag = 0;
	s_tTmr[i].Mode = TMR_ONCE_MODE; /* 缺省是 1 次性工作模式 */
	}
	/*
	配置 systic 中断周期为 1ms，并启动 systick 中断。
	SystemCoreClock 是固件中定义的系统内核时钟，对于 STM32F4XX,一般为 168MHz
	SysTick_Config() 函数的形参表示内核时钟多少个周期后触发一次 Systick 定时中断.
	-- SystemCoreClock / 1000 表示定时频率为 1000Hz， 也就是定时周期为 1ms
	-- SystemCoreClock / 500 表示定时频率为 500Hz， 也就是定时周期为 2ms
	-- SystemCoreClock / 2000 表示定时频率为 2000Hz， 也就是定时周期为 500us
	对于常规的应用，我们一般取定时周期 1ms。对于低速 CPU 或者低功耗应用，可以设置定时周期为 10ms
	*/
	SysTick_Config(SystemCoreClock / 1000);
}

 3.嘀嗒定时器中断，用来以一定的时间间隔刷新调度器

刷新函数的主要功能是：每个时标中断执行一次，在嘀嗒定时器中断里面执行。当刷新函数确定某个
合作式任务要执行的时候，将这个任务结构体的成员 RunMe 加 1，要注意的是刷新任务不执行任何合作
式任务，这里只是设置 一下 RunMe 标志，由调度函数根据此标志执行相应任务。抢占式任务需要执行
的话，立即就会得到执行。
下面是具体的函数代码：
/*
*********************************************************************************************************
* 函 数 名: hSCH_Update(void)
* 功能说明: 调度器的刷新函数，每个时标中断执行一次。在嘀嗒定时器中断里面执行。
* 当刷新函数确定某个任务要执行的时候，将 RunMe 加 1，要注意的是刷新任务
* 不执行任何函数，需要运行的任务有调度函数激活。
* 抢占式任务需要执行的话，立即就会得到执行。
* 形 参：无
* 返 回 值: 无
*********************************************************************************************************
*/
void hSCH_Update(void)
{
	tByte index;
	/*注意计数单位是时标，不是毫秒*/
	for(index = 0; index < hSCH_MAX_TASKS; index++)
	{
		if(hSCH_task_G[index].pTask) /*检测这里是否有任务*/
		{
			if(hSCH_task_G[index].Delay == 0)
			{
				if(hSCH_task_G[index].Co_op)
				{
					hSCH_task_G[index].RunMe += 1; /*合作式任务需要运行 将 RunMe 置 1*/
				}
				else
				{
					(*hSCH_task_G[index].pTask)(); /*抢占式任务需要立即运行 将 RunMe 减 1*/
					//hSCH_task_G[index].RunMe -= 1;
					if(hSCH_task_G[index].Period == 0)
					{ /*单次执行的任务 则将其清除*/
						hSCH_task_G[index].pTask = 0;
					}
				}
				if(hSCH_task_G[index].Period)
				{ /*调度周期性的任务再次执行*/
					hSCH_task_G[index].Delay = hSCH_task_G[index].Period;
				}
			}
			else
			{ /*还有准备好运行*/
				hSCH_task_G[index].Delay -= 1;
			}
		}
	}
}
 4.向调度器增加任务函数
添加任务函数的主要功能是将任务添加到任务队列上，下面主要是说一下这个函数中参数的功能：
tByte hSCH_Add_Task(void (*pFuntion)(void),
					tWord DELAY,
					tWord PERIOD,
					tByte Co_op)；
1. void (*pFuntion)(void) ：表示函数的地址，也就是将函数名填进去就行了。
2. DELAY ：表示函数第一次运行需要等待的时间。
3. PERIOD：表示函数周期性执行的时间间隔
4. Co_op：混合式调度和合作式调度的区分 合作式用 1 表示 抢占式用 0 表示
举四个例子说明一下：
 hSCH_Add_Task(DOTASK, 1000, 0, 0)
抢占式任务，DOTASK 是函数的运行地址，1000 是 1000 个时标以后开始运行，只运行一次。
 hSCH_Add_Task(DOTASK, 0, 1000，0)
抢占式任务，DOTASK 是函数的运行地址，每个 1000 个时标周期性的运行一次。
 hSCH_Add_Task(DOTASK, 300, 1000, 1)
合作式任务，DOTASK 是函数的运行地址，300 是 300 个时标以后开始运行，以后就是每 1000 个时
标周期运行一次，也就是说运行时刻是 300，1300，2300，3300，4300 等等。
 Task_ID = hSCH_Add_Task(DOTASK,1000,0);
Task_ID 是任务标示符，将任务标示符保存 以便以后删除任务。
 5.使任务在应当运行的时候被执行的调度函数
 6.从调度器删除任务的函数（此功能未做）
/*
*********************************************************************************************************
* 函 数 名: hSCH_Add_Task
* 功能说明: 添加任务。
* 形 参： void (*pFuntion)(void) tWord DELAY tWord PERIOD tByte Co_op)
* 返 回 值: 返回任务的 ID 号
*********************************************************************************************************
*/
tByte hSCH_Add_Task(void (*pFuntion)(void),
					tWord DELAY,
					tWord PERIOD,
					tByte Co_op) /*任务合作式和抢占式的区分*/
{
	tByte index = 0; /*首先在队列中找到一个空隙，（如果有的话） */
	while((hSCH_task_G[index].pTask != 0) && (index <hSCH_MAX_TASKS))
	{
		index ++;
	}
	if(index == hSCH_MAX_TASKS)/*超过最大的任务数目 则返错误信息*/
	{
		Error_code_G = ERROR_SCH_TOO_MANY_TASKS;/*设置全局错误变量*/
		return hSCH_MAX_TASKS;
	}
	hSCH_task_G[index].pTask = pFuntion; /*运行到这里说明申请的任务块成功*/
	hSCH_task_G[index].Delay = DELAY;
	hSCH_task_G[index].Period = PERIOD;
	hSCH_task_G[index].RunMe = 0;
	hSCH_task_G[index].Co_op = Co_op;
	return index; /*返回任务的位置，以便于以后删除*/
}
调度函数
在前面已经说过，刷新函数不执行任何合作式任务，需要运行的任务由调度函数激活。下面是调度函
数的源码：
/*
*********************************************************************************************************
* 函 数 名: hSCH_Dispatch_Tasks
* 功能说明: 在主任务里面执行的调度函数。
* 形 参：无
* 返 回 值: 无
*********************************************************************************************************
*/
void hSCH_Dispatch_Tasks(void)
{
	tByte index;
	/*运行下一个任务，如果下一个任务准备就绪的话*/
	for(index = 0; index < hSCH_MAX_TASKS; index++)
	{
		if((hSCH_task_G[index].RunMe >0) && (hSCH_task_G[index].Co_op)) /*只调度合作式任务*/
		{
			(*hSCH_task_G[index].pTask)(); /*执行任务 */
			hSCH_task_G[index].RunMe -= 1; /*执行任务完成后，将 RunMe 减一 */
			if(hSCH_task_G[index].Period == 0) /*如果是单次任务的话，则将任务删除 */
			{
				hSCH_Task_Delete(index);
			}
		}
	}
}
有上面的五步，一个简单的合作式调度器就算设计完成了。

为了更好的使用混合式式调度器，这里简单的总结写使用注意事项：
 建立数量满足要求的混合式任务，很可能因为一个或者多个任务的运行时间大于时标间隔，所以需要
使用混合式调度器。混合式调度器的使用是安全的，然而必须的保存任务不重叠。
 实现一个抢占式任务，这种任务一般在每个时标间隔调用，这种任务常用来检测错误或者紧急事件。
 抢占式任务可以中断合作式任务。
 抢占式任务必须的简短，运行时间最多不能超多时间间隔%50，否则将极大的削弱系统的性能。
 在所有的状态下仔细测试该系统，检测错误。
关于时间触发方式的调度器设计，就跟大家讲这么多，有兴趣的可以查阅相关资料做深入的了解。